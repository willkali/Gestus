name: CI - Valida√ß√£o de Padr√µes Gestus

on:
  push:
    branches: [ main, dev ]
  pull_request:
    branches: [ main, dev ]

env:
  DOTNET_VERSION: '10.0.x'
  SOLUTION_PATH: 'Gestus.sln'

jobs:
  # ============================================
  # Job 1: Valida√ß√£o de Formata√ß√£o
  # ============================================
  format-validation:
    name: üé® Valida√ß√£o de Formata√ß√£o
    runs-on: ubuntu-latest
    
    steps:
    - name: üì• Checkout c√≥digo
      uses: actions/checkout@v4
      
    - name: üîß Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}
        
    - name: üì¶ Restaurar depend√™ncias
      run: dotnet restore ${{ env.SOLUTION_PATH }}
      
    - name: üé® Verificar formata√ß√£o
      run: |
        dotnet format ${{ env.SOLUTION_PATH }} --verify-no-changes --verbosity diagnostic
        if [ $? -ne 0 ]; then
          echo "‚ùå C√≥digo n√£o est√° formatado corretamente!"
          echo "Execute: dotnet format"
          exit 1
        fi
        echo "‚úÖ Formata√ß√£o OK!"

  # ============================================
  # Job 2: An√°lise Est√°tica e Build
  # ============================================
  build-and-analyze:
    name: üî® Build e An√°lise Est√°tica
    runs-on: ubuntu-latest
    
    steps:
    - name: üì• Checkout c√≥digo
      uses: actions/checkout@v4
      
    - name: üîß Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}
        
    - name: üì¶ Restaurar depend√™ncias
      run: dotnet restore ${{ env.SOLUTION_PATH }}
      
    - name: üî® Build
      run: |
        dotnet build ${{ env.SOLUTION_PATH }} \
          --configuration Release \
          --no-restore \
          /p:TreatWarningsAsErrors=true \
          /p:WarningLevel=4
          
    - name: üìä An√°lise de c√≥digo
      run: |
        dotnet build ${{ env.SOLUTION_PATH }} \
          --configuration Release \
          --no-restore \
          /p:RunAnalyzers=true \
          /p:EnforceCodeStyleInBuild=true

  # ============================================
  # Job 3: Testes
  # ============================================
  tests:
    name: üß™ Testes
    runs-on: ubuntu-latest
    needs: build-and-analyze
    
    steps:
    - name: üì• Checkout c√≥digo
      uses: actions/checkout@v4
      
    - name: üîß Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}
        
    - name: üì¶ Restaurar depend√™ncias
      run: dotnet restore ${{ env.SOLUTION_PATH }}
      
    - name: üî® Build
      run: dotnet build ${{ env.SOLUTION_PATH }} --configuration Release --no-restore
      
    - name: üß™ Executar testes
      run: |
        dotnet test ${{ env.SOLUTION_PATH }} \
          --configuration Release \
          --no-build \
          --verbosity normal \
          --logger "trx;LogFileName=test-results.trx" \
          --collect:"XPlat Code Coverage" \
          --results-directory ./TestResults
          
    - name: üìä Upload resultados dos testes
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: test-results
        path: ./TestResults
        
    - name: üìà Publicar cobertura
      if: always()
      uses: codecov/codecov-action@v3
      with:
        files: ./TestResults/**/coverage.cobertura.xml
        flags: unittests
        name: codecov-gestus

  # ============================================
  # Job 4: Valida√ß√£o de Nomenclatura
  # ============================================
  naming-validation:
    name: üìù Valida√ß√£o de Nomenclatura
    runs-on: ubuntu-latest
    
    steps:
    - name: üì• Checkout c√≥digo
      uses: actions/checkout@v4
      
    - name: üîß Setup PowerShell
      run: |
        # PowerShell j√° vem instalado no Ubuntu runner
        pwsh --version
      
    - name: üîç Verificar nomenclatura em portugu√™s
      shell: pwsh
      run: |
        Write-Host "üîç Verificando nomenclatura em portugu√™s..."
        
        # Whitelist de acr√¥nimos permitidos
        $AcronimosPermitidos = @(
          'API', 'HTTP', 'HTTPS', 'URL', 'URI', 'XML', 'JSON', 'JWT',
          'OAUTH', 'SAML', 'LDAP', 'AD', 'IAM', 'DTO', 'DAO', 'CRUD',
          'UUID', 'GUID', 'SQL', 'TCP', 'IP', 'FTP', 'SMTP', 'LINQ'
        )
        
        $EnglishFiles = @()
        $CsFiles = Get-ChildItem -Path . -Recurse -Filter *.cs | Where-Object {
          $_.FullName -notmatch '[\\/]obj[\\/]' -and 
          $_.FullName -notmatch '[\\/]bin[\\/]' -and
          $_.FullName -notmatch 'Migrations'
        }
        
        foreach ($File in $CsFiles) {
          $Content = Get-Content $File.FullName -Raw
          
          # Padr√µes de classes/interfaces/enums em ingl√™s comuns
          $EnglishPatterns = @(
            'public\s+class\s+User\b',
            'public\s+class\s+Role\b',
            'public\s+class\s+Permission\b',
            'public\s+class\s+Application\b',
            'public\s+class\s+Group\b',
            'public\s+interface\s+IUser',
            'public\s+interface\s+IRole',
            'public\s+interface\s+IPermission',
            'public\s+enum\s+UserStatus',
            'public\s+enum\s+RoleType'
          )
          
          foreach ($Pattern in $EnglishPatterns) {
            if ($Content -match $Pattern) {
              $Match = $Matches[0]
              
              # Extrair nome da classe/interface/enum
              if ($Match -match '\s+(\w+)(?:\s|$)') {
                $NomeClasse = $Matches[1]
                
                # Verificar se N√ÉO √© acr√¥nimo permitido
                $IsAcronym = $false
                foreach ($Acronimo in $AcronimosPermitidos) {
                  if ($NomeClasse -eq $Acronimo -or $NomeClasse -like "*$Acronimo" -or $NomeClasse -like "$Acronimo*") {
                    $IsAcronym = $true
                    break
                  }
                }
                
                if (-not $IsAcronym) {
                  $RelPath = $File.FullName.Replace($PWD.Path, '.').Replace('\', '/')
                  $EnglishFiles += "$RelPath : $Match"
                }
              }
            }
          }
        }
        
        if ($EnglishFiles.Count -gt 0) {
          Write-Host "‚ùå Encontradas classes/interfaces em ingl√™s:" -ForegroundColor Red
          $EnglishFiles | ForEach-Object { Write-Host "  $_" }
          Write-Host ""
          Write-Host "üìã Padr√£o: Classes devem estar em portugu√™s" -ForegroundColor Yellow
          Write-Host "Exemplos: Usuario, Papel, Permissao, Aplicacao, Grupo"
          exit 1
        }
        
        Write-Host "‚úÖ Nomenclatura OK!" -ForegroundColor Green
        
    - name: üîç Verificar sufixo Async
      shell: pwsh
      run: |
        Write-Host "üîç Verificando sufixo Async..."
        
        $MissingAsync = @()
        $CsFiles = Get-ChildItem -Path . -Recurse -Filter *.cs | Where-Object {
          $_.FullName -notmatch '[\\/]obj[\\/]' -and 
          $_.FullName -notmatch '[\\/]bin[\\/]' -and
          $_.FullName -notmatch 'Migrations'
        }
        
        foreach ($File in $CsFiles) {
          $Content = Get-Content $File.FullName -Raw
          
          # Procurar m√©todos async sem sufixo Async
          $Matches = [regex]::Matches($Content, 'public\s+async\s+Task[<>]?.*?\s+(\w+)\s*\(')
          foreach ($Match in $Matches) {
            $MethodName = $Match.Groups[1].Value
            if ($MethodName -notmatch 'Async$') {
              $RelPath = $File.FullName.Replace($PWD.Path, '.').Replace('\', '/')
              $MissingAsync += "$RelPath : $MethodName"
            }
          }
        }
        
        if ($MissingAsync.Count -gt 0) {
          Write-Host "‚ùå M√©todos async sem sufixo 'Async':" -ForegroundColor Red
          $MissingAsync | ForEach-Object { Write-Host "  $_" }
          Write-Host ""
          Write-Host "üìã Padr√£o: M√©todos async devem ter sufixo 'Async'" -ForegroundColor Yellow
          exit 1
        }
        
        Write-Host "‚úÖ Sufixo Async OK!" -ForegroundColor Green

  # ============================================
  # Job 5: Valida√ß√£o de Estrutura
  # ============================================
  structure-validation:
    name: üèóÔ∏è Valida√ß√£o de Estrutura
    runs-on: ubuntu-latest
    
    steps:
    - name: üì• Checkout c√≥digo
      uses: actions/checkout@v4
      
    - name: üîç Verificar um arquivo = uma classe
      run: |
        echo "üîç Verificando estrutura de arquivos..."
        
        # Verificar arquivos com m√∫ltiplas classes p√∫blicas
        MULTI_CLASS_FILES=$(find . -name "*.cs" \
          -not -path "*/bin/*" \
          -not -path "*/obj/*" \
          -not -path "*/Migrations/*" \
          -exec sh -c '
            PUBLIC_CLASSES=$(grep -c "^[[:space:]]*public class\|^[[:space:]]*public interface\|^[[:space:]]*public enum" "$1" 2>/dev/null || echo 0)
            if [ "$PUBLIC_CLASSES" -gt 1 ]; then
              echo "$1 tem $PUBLIC_CLASSES classes/interfaces/enums p√∫blicos"
            fi
          ' _ {} \; || true)
        
        if [ ! -z "$MULTI_CLASS_FILES" ]; then
          echo "‚ùå Arquivos com m√∫ltiplas classes p√∫blicas:"
          echo "$MULTI_CLASS_FILES"
          echo ""
          echo "üìã Padr√£o: Um arquivo = Uma classe/interface/enum"
          exit 1
        fi
        
        echo "‚úÖ Estrutura de arquivos OK!"
        
    - name: üîç Verificar DTOs fora de controllers
      run: |
        echo "üîç Verificando DTOs em controllers..."
        
        # Verificar se h√° DTOs definidos dentro de controllers
        DTOS_IN_CONTROLLERS=$(find ./Gestus.Api/Controllers -name "*.cs" 2>/dev/null \
          -exec grep -l "public class.*Request\|public class.*Response\|public class.*Dto" {} \; || true)
        
        if [ ! -z "$DTOS_IN_CONTROLLERS" ]; then
          echo "‚ùå DTOs encontrados dentro de controllers:"
          echo "$DTOS_IN_CONTROLLERS"
          echo ""
          echo "üìã Padr√£o: DTOs devem estar em Gestus.Application/DTOs/"
          exit 1
        fi
        
        echo "‚úÖ DTOs OK!"

  # ============================================
  # Job 6: Valida√ß√£o de Seguran√ßa
  # ============================================
  security-validation:
    name: üîí Valida√ß√£o de Seguran√ßa
    runs-on: ubuntu-latest
    
    steps:
    - name: üì• Checkout c√≥digo
      uses: actions/checkout@v4
      
    - name: üîç Verificar senhas em logs
      run: |
        echo "üîç Verificando logs de dados sens√≠veis..."
        
        # Verificar se h√° logs de senhas/tokens
        SENSITIVE_LOGS=$(grep -r --include="*.cs" \
          -iE "LogInformation.*senha|LogDebug.*senha|LogWarning.*senha|LogError.*senha" \
          --exclude-dir={bin,obj,Migrations} \
          . || true)
        
        if [ ! -z "$SENSITIVE_LOGS" ]; then
          echo "‚ö†Ô∏è AVISO: Poss√≠vel log de dados sens√≠veis:"
          echo "$SENSITIVE_LOGS"
          echo ""
          echo "üìã Padr√£o: NUNCA logar senhas, tokens ou dados sens√≠veis"
          echo "Revise manualmente se isso √© realmente um problema"
        fi
        
        # Verificar secrets em appsettings
        SECRETS_IN_CONFIG=$(grep -r --include="appsettings*.json" \
          -iE "password.*:.*[^{]|secret.*:.*[^{]|key.*:.*[^{]" \
          --exclude="appsettings.json" \
          . || true)
        
        if [ ! -z "$SECRETS_IN_CONFIG" ]; then
          echo "‚ùå Secrets encontrados em arquivos de configura√ß√£o:"
          echo "$SECRETS_IN_CONFIG"
          echo ""
          echo "üìã Padr√£o: Usar vari√°veis de ambiente ou User Secrets"
          exit 1
        fi
        
        echo "‚úÖ Valida√ß√£o de seguran√ßa OK!"

  # ============================================
  # Job 7: Valida√ß√£o de Documenta√ß√£o
  # ============================================
  documentation-validation:
    name: üìö Valida√ß√£o de Documenta√ß√£o
    runs-on: ubuntu-latest
    
    steps:
    - name: üì• Checkout c√≥digo
      uses: actions/checkout@v4
      
    - name: üîç Verificar XML comments
      shell: pwsh
      run: |
        Write-Host "üîç Verificando documenta√ß√£o XML..." -ForegroundColor Cyan
        Write-Host ""
        
        # Verificar classes p√∫blicas sem XML comments
        $MissingDocs = @()
        $CsFiles = Get-ChildItem -Path . -Recurse -Filter *.cs | Where-Object {
          $_.FullName -notmatch '[\\/]obj[\\/]' -and 
          $_.FullName -notmatch '[\\/]bin[\\/]' -and
          $_.FullName -notmatch 'Migrations'
        }
        
        foreach ($File in $CsFiles) {
          $Content = Get-Content $File.FullName -Raw
          
          # Procurar classes/interfaces/enums p√∫blicos sem XML comments
          $PublicTypes = [regex]::Matches($Content, 'public\s+(class|interface|enum)\s+(\w+)')
          
          foreach ($Match in $PublicTypes) {
            $TypeName = $Match.Groups[2].Value
            $Position = $Match.Index
            
            # Pegar as 5 linhas anteriores para verificar se h√° XML comment
            $BeforeMatch = $Content.Substring(0, $Position)
            $Lines = $BeforeMatch -split "`n"
            $PreviousLines = $Lines | Select-Object -Last 5
            
            # Verificar se h√° /// <summary> nas linhas anteriores
            $HasXmlComment = $false
            foreach ($Line in $PreviousLines) {
              if ($Line -match '///\s*<summary>') {
                $HasXmlComment = $true
                break
              }
            }
            
            if (-not $HasXmlComment) {
              $RelPath = $File.FullName.Replace($PWD.Path, '.').Replace('\', '/')
              $MissingDocs += "$RelPath : $TypeName"
            }
          }
        }
        
        if ($MissingDocs.Count -gt 0) {
          Write-Host "‚ùå Encontradas $($MissingDocs.Count) classe(s)/interface(s) sem XML comments:" -ForegroundColor Red
          $MissingDocs | Select-Object -First 10 | ForEach-Object { 
            Write-Host "  $_" -ForegroundColor Gray 
          }
          
          if ($MissingDocs.Count -gt 10) {
            Write-Host "  ... e mais $($MissingDocs.Count - 10) arquivo(s)" -ForegroundColor Gray
          }
          
          Write-Host "" 
          Write-Host "üìã Padr√£o: Classes p√∫blicas DEVEM ter XML comments" -ForegroundColor Yellow
          Write-Host "Exemplo:" -ForegroundColor White
          Write-Host "/// <summary>"
          Write-Host "/// Descri√ß√£o da classe"
          Write-Host "/// </summary>"
          Write-Host "public class MinhaClasse { }"
          
          exit 1
        } else {
          Write-Host "‚úÖ Documenta√ß√£o XML completa!" -ForegroundColor Green
        }

  # ============================================
  # Job Final: Resumo
  # ============================================
  summary:
    name: üìä Resumo da Valida√ß√£o
    runs-on: ubuntu-latest
    needs: [format-validation, build-and-analyze, tests, naming-validation, structure-validation, security-validation, documentation-validation]
    if: always()
    
    steps:
    - name: üìä Gerar resumo
      run: |
        echo "# üìä Resumo da Valida√ß√£o de Padr√µes" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "## ‚úÖ Valida√ß√µes Executadas" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "- üé® Formata√ß√£o de c√≥digo" >> $GITHUB_STEP_SUMMARY
        echo "- üî® Build e an√°lise est√°tica" >> $GITHUB_STEP_SUMMARY
        echo "- üß™ Testes unit√°rios" >> $GITHUB_STEP_SUMMARY
        echo "- üìù Nomenclatura em portugu√™s" >> $GITHUB_STEP_SUMMARY
        echo "- üèóÔ∏è Estrutura de arquivos" >> $GITHUB_STEP_SUMMARY
        echo "- üîí Seguran√ßa (logs e secrets)" >> $GITHUB_STEP_SUMMARY
        echo "- üìö Documenta√ß√£o XML" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "## üìã Padr√µes Gestus" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "Todos os padr√µes definidos em PADRONIZACAO.md foram validados!" >> $GITHUB_STEP_SUMMARY
        
    - name: ‚úÖ Sucesso
      if: ${{ needs.format-validation.result == 'success' && needs.build-and-analyze.result == 'success' && needs.tests.result == 'success' && needs.naming-validation.result == 'success' && needs.structure-validation.result == 'success' && needs.security-validation.result == 'success' }}
      run: |
        echo "‚úÖ Todas as valida√ß√µes passaram!"
        echo "O c√≥digo est√° em conformidade com os padr√µes Gestus!"
        
    - name: ‚ùå Falha
      if: ${{ needs.format-validation.result == 'failure' || needs.build-and-analyze.result == 'failure' || needs.tests.result == 'failure' || needs.naming-validation.result == 'failure' || needs.structure-validation.result == 'failure' || needs.security-validation.result == 'failure' }}
      run: |
        echo "‚ùå Algumas valida√ß√µes falharam!"
        echo "Revise os logs acima para detalhes"
        exit 1
