using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Identity;
using Microsoft.AspNetCore.Authorization;
using OpenIddict.Abstractions;
using OpenIddict.Server.AspNetCore;
using Gestus.Modelos;
using System.Security.Claims;
using Microsoft.EntityFrameworkCore;
using System.ComponentModel.DataAnnotations;
using System.Text.Json;

namespace Gestus.Controllers;

/// <summary>
/// Controlador respons√°vel pela autentica√ß√£o de usu√°rios
/// </summary>
[ApiController]
[Route("api/[controller]")]
[Produces("application/json")]
public class AutenticacaoController : ControllerBase
{
    private readonly UserManager<Usuario> _userManager;
    private readonly SignInManager<Usuario> _signInManager;
    private readonly RoleManager<Papel> _roleManager;
    private readonly ILogger<AutenticacaoController> _logger;

    public AutenticacaoController(
        UserManager<Usuario> userManager,
        SignInManager<Usuario> signInManager,
        RoleManager<Papel> roleManager,
        ILogger<AutenticacaoController> logger)
    {
        _userManager = userManager;
        _signInManager = signInManager;
        _roleManager = roleManager;
        _logger = logger;
    }

    /// <summary>
    /// Realiza o login do usu√°rio
    /// </summary>
    /// <param name="request">Dados de login</param>
    /// <returns>Token de acesso e informa√ß√µes do usu√°rio</returns>
    [HttpPost("login")]
    [ProducesResponseType(typeof(RespostaLogin), StatusCodes.Status200OK)]
    [ProducesResponseType(typeof(RespostaErro), StatusCodes.Status400BadRequest)]
    [ProducesResponseType(typeof(RespostaErro), StatusCodes.Status401Unauthorized)]
    public async Task<IActionResult> Login([FromBody] SolicitacaoLogin request)
    {
        try
        {
            _logger.LogInformation("üîê Tentativa de login para: {Email}", request.Email);

            // Validar dados de entrada
            if (!ModelState.IsValid)
            {
                return BadRequest(new RespostaErro
                {
                    Erro = "DadosInvalidos",
                    Mensagem = "Dados de login inv√°lidos",
                    Detalhes = ModelState.Values.SelectMany(v => v.Errors).Select(e => e.ErrorMessage).ToList()
                });
            }

            // ‚úÖ USAR TOKENS REAIS: Redirecionar para endpoint OpenIddict
            using var httpClient = new HttpClient();
            
            // Fazer requisi√ß√£o para nosso endpoint de token
            var baseUrl = $"{Request.Scheme}://{Request.Host}";
            var tokenEndpoint = $"{baseUrl}/connect/token";
            
            var tokenRequest = new FormUrlEncodedContent(new[]
            {
                new KeyValuePair<string, string>("grant_type", "password"),
                new KeyValuePair<string, string>("client_id", "gestus_api"),
                new KeyValuePair<string, string>("client_secret", "gestus_api_secret_2024"),
                new KeyValuePair<string, string>("username", request.Email),
                new KeyValuePair<string, string>("password", request.Senha),
                new KeyValuePair<string, string>("scope", "openid profile email roles")
            });

            var response = await httpClient.PostAsync(tokenEndpoint, tokenRequest);
            
            if (!response.IsSuccessStatusCode)
            {
                var errorContent = await response.Content.ReadAsStringAsync();
                _logger.LogWarning("‚ö†Ô∏è Erro no token endpoint: {Error}", errorContent);
                
                return Unauthorized(new RespostaErro
                {
                    Erro = "CredenciaisInvalidas",
                    Mensagem = "Email ou senha incorretos"
                });
            }

            var tokenResponse = await response.Content.ReadAsStringAsync();
            var tokenData = System.Text.Json.JsonSerializer.Deserialize<JsonElement>(tokenResponse);
            
            var accessToken = tokenData.GetProperty("access_token").GetString()!;
            var expiresIn = tokenData.GetProperty("expires_in").GetInt32();
            var refreshToken = tokenData.TryGetProperty("refresh_token", out var rt) ? rt.GetString() : null;

            // Buscar informa√ß√µes do usu√°rio
            var usuario = await _userManager.FindByEmailAsync(request.Email);
            var papeis = await _userManager.GetRolesAsync(usuario!);
            var permissoes = await ObterPermissoesUsuario(usuario!.Id);

            _logger.LogInformation("‚úÖ Login realizado com sucesso para: {Email}", request.Email);

            return Ok(new RespostaLogin
            {
                Sucesso = true,
                Token = accessToken,
                TipoToken = "Bearer",
                ExpiracaoEm = DateTime.UtcNow.AddSeconds(expiresIn),
                RefreshToken = refreshToken ?? "",
                Usuario = new InformacoesUsuario
                {
                    Id = usuario!.Id,
                    Email = usuario.Email!,
                    Nome = usuario.Nome,
                    Sobrenome = usuario.Sobrenome,
                    NomeCompleto = usuario.NomeCompleto ?? $"{usuario.Nome} {usuario.Sobrenome}",
                    UltimoLogin = usuario.UltimoLogin,
                    Papeis = papeis.ToList(),
                    Permissoes = permissoes
                }
            });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "‚ùå Erro durante o login para: {Email}", request.Email);
            return StatusCode(500, new RespostaErro
            {
                Erro = "ErroInterno",
                Mensagem = "Erro interno do servidor"
            });
        }
    }

    /// <summary>
    /// Renova o token de acesso usando o refresh token
    /// </summary>
    /// <param name="request">Refresh token</param>
    /// <returns>Novo token de acesso</returns>
    [HttpPost("refresh")]
    [ProducesResponseType(typeof(RespostaToken), StatusCodes.Status200OK)]
    [ProducesResponseType(typeof(RespostaErro), StatusCodes.Status400BadRequest)]
    [ProducesResponseType(typeof(RespostaErro), StatusCodes.Status401Unauthorized)]
    public IActionResult Refresh([FromBody] SolicitacaoRefresh request)
    {
        try
        {
            _logger.LogInformation("üîÑ Tentativa de renova√ß√£o de token");

            if (!ModelState.IsValid || string.IsNullOrEmpty(request.RefreshToken))
            {
                return BadRequest(new RespostaErro
                {
                    Erro = "RefreshTokenInvalido",
                    Mensagem = "Refresh token √© obrigat√≥rio"
                });
            }

            // TODO: Implementar valida√ß√£o do refresh token com OpenIddict
            // Por enquanto, retornamos erro para implementar depois
            
            return Unauthorized(new RespostaErro
            {
                Erro = "RefreshTokenExpirado",
                Mensagem = "Refresh token inv√°lido ou expirado. Fa√ßa login novamente."
            });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "‚ùå Erro durante renova√ß√£o do token");
            return StatusCode(500, new RespostaErro
            {
                Erro = "ErroInterno",
                Mensagem = "Erro interno do servidor"
            });
        }
    }

    /// <summary>
    /// Realiza o logout do usu√°rio
    /// </summary>
    /// <returns>Confirma√ß√£o de logout</returns>
    [HttpPost("logout")]
    [Authorize]
    [ProducesResponseType(typeof(RespostaSucesso), StatusCodes.Status200OK)]
    public IActionResult Logout() // ‚úÖ Removido async - m√©todo s√≠ncrono
    {
        try
        {
            // Para logout real, invalidar√≠amos o token no OpenIddict
            // Por enquanto, apenas confirmamos o logout
            return Ok(new RespostaSucesso
            {
                Sucesso = true,
                Mensagem = "Logout realizado com sucesso"
            });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "‚ùå Erro durante logout");
            return StatusCode(500, new RespostaErro
            {
                Erro = "ErroInterno",
                Mensagem = "Erro interno do servidor"
            });
        }
    }

    /// <summary>
    /// Obt√©m informa√ß√µes do usu√°rio autenticado
    /// </summary>
    /// <returns>Informa√ß√µes do usu√°rio logado</returns>
    [HttpGet("perfil")]
    [Authorize]
    [ProducesResponseType(typeof(InformacoesUsuario), StatusCodes.Status200OK)]
    [ProducesResponseType(typeof(RespostaErro), StatusCodes.Status401Unauthorized)]
    public async Task<IActionResult> ObterPerfil()
    {
        try
        {
            // ‚úÖ CORRIGIR: OpenIddict usa claim "sub" para subject (user ID)
            var userId = User.FindFirstValue(OpenIddictConstants.Claims.Subject) ?? 
                        User.FindFirstValue(ClaimTypes.NameIdentifier) ??
                        User.FindFirstValue("sub");

            _logger.LogInformation("üîç Obtendo perfil para usu√°rio: {UserId}", userId);

            if (string.IsNullOrEmpty(userId) || !int.TryParse(userId, out var userIdInt))
            {
                _logger.LogWarning("‚ö†Ô∏è UserId inv√°lido no token");
                return Unauthorized(new RespostaErro
                {
                    Erro = "TokenInvalido",
                    Mensagem = "Token n√£o cont√©m ID de usu√°rio v√°lido"
                });
            }

            var usuario = await _userManager.FindByIdAsync(userId);
            if (usuario == null || !usuario.Ativo)
            {
                _logger.LogWarning("‚ö†Ô∏è Usu√°rio n√£o encontrado ou inativo: {UserId}", userId);
                return Unauthorized(new RespostaErro
                {
                    Erro = "UsuarioInvalido",
                    Mensagem = "Usu√°rio n√£o encontrado ou inativo"
                });
            }

            var papeis = await _userManager.GetRolesAsync(usuario);
            var permissoes = await ObterPermissoesUsuario(usuario.Id);

            _logger.LogInformation("‚úÖ Perfil obtido com sucesso para: {Email}", usuario.Email);

            return Ok(new InformacoesUsuario
            {
                Id = usuario.Id,
                Email = usuario.Email!,
                Nome = usuario.Nome,
                Sobrenome = usuario.Sobrenome,
                NomeCompleto = usuario.NomeCompleto ?? $"{usuario.Nome} {usuario.Sobrenome}",
                UltimoLogin = usuario.UltimoLogin,
                Papeis = papeis.ToList(),
                Permissoes = permissoes
            });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "‚ùå Erro ao obter perfil do usu√°rio");
            return StatusCode(500, new RespostaErro
            {
                Erro = "ErroInterno",
                Mensagem = "Erro interno do servidor"
            });
        }
    }

    /// <summary>
    /// Verifica se o token √© v√°lido
    /// </summary>
    /// <returns>Status do token</returns>
    [HttpGet("validar-token")]
    [Authorize] // ‚úÖ USAR AUTHORIZE ao inv√©s de valida√ß√£o manual
    [ProducesResponseType(typeof(RespostaValidacaoToken), StatusCodes.Status200OK)]
    [ProducesResponseType(typeof(RespostaErro), StatusCodes.Status401Unauthorized)]
    public async Task<IActionResult> ValidarToken()
    {
        try
        {
            // ‚úÖ CORRIGIR: OpenIddict usa claim "sub" para subject (user ID)
            var userId = User.FindFirstValue(OpenIddictConstants.Claims.Subject) ?? 
                        User.FindFirstValue(ClaimTypes.NameIdentifier) ??
                        User.FindFirstValue("sub");
            
            var email = User.FindFirstValue(OpenIddictConstants.Claims.Email) ?? 
                       User.FindFirstValue(ClaimTypes.Email);
            
            var name = User.FindFirstValue(OpenIddictConstants.Claims.Name) ?? 
                      User.FindFirstValue(ClaimTypes.Name);

            _logger.LogInformation("üîç Claims do token - UserId: {UserId}, Email: {Email}, Name: {Name}", 
                userId, email, name);

            // ‚úÖ LOG TODOS OS CLAIMS para debug
            var allClaims = User.Claims.Select(c => new { c.Type, c.Value }).ToList();
            _logger.LogInformation("üîç Todos os claims: {@Claims}", allClaims);

            if (string.IsNullOrEmpty(userId))
            {
                _logger.LogWarning("‚ö†Ô∏è Token v√°lido mas sem claim de usu√°rio");
                return Unauthorized(new RespostaErro
                {
                    Erro = "TokenInvalido",
                    Mensagem = "Token n√£o cont√©m informa√ß√µes v√°lidas do usu√°rio"
                });
            }

            // ‚úÖ TENTAR CONVERTER PARA INT
            if (!int.TryParse(userId, out var userIdInt))
            {
                _logger.LogWarning("‚ö†Ô∏è UserId n√£o √© um n√∫mero v√°lido: {UserId}", userId);
                return Unauthorized(new RespostaErro
                {
                    Erro = "TokenInvalido",
                    Mensagem = "Formato de ID de usu√°rio inv√°lido"
                });
            }

            var usuario = await _userManager.FindByIdAsync(userId);
            if (usuario == null || !usuario.Ativo)
            {
                _logger.LogWarning("‚ö†Ô∏è Usu√°rio n√£o encontrado ou inativo: {UserId}", userId);
                return Unauthorized(new RespostaErro
                {
                    Erro = "UsuarioInvalido",
                    Mensagem = "Usu√°rio n√£o encontrado ou inativo"
                });
            }

            // Obter pap√©is e permiss√µes
            var papeis = await _userManager.GetRolesAsync(usuario);
            var permissoes = await ObterPermissoesUsuario(usuario.Id);
            var expiracao = GetTokenExpiration();

            _logger.LogInformation("‚úÖ Token validado com sucesso para usu√°rio: {Email}", usuario.Email);

            return Ok(new RespostaValidacaoToken
            {
                Valido = true,
                UsuarioId = userId,
                Email = usuario.Email,
                Papeis = papeis.ToList(),
                Permissoes = permissoes,
                ExpiracaoEm = expiracao
            });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "‚ùå Erro durante valida√ß√£o de token");
            return StatusCode(500, new RespostaErro
            {
                Erro = "ErroInterno",
                Mensagem = "Erro interno do servidor"
            });
        }
    }

    #region M√©todos Privados

    /// <summary>
    /// Obt√©m todas as permiss√µes de um usu√°rio (atrav√©s dos pap√©is)
    /// </summary>
    private async Task<List<string>> ObterPermissoesUsuario(int usuarioId)
    {
        var usuario = await _userManager.Users
            .Where(u => u.Id == usuarioId)
            .FirstOrDefaultAsync();

        if (usuario == null) return new List<string>();

        var papeis = await _userManager.GetRolesAsync(usuario);
        
        // Buscar permiss√µes atrav√©s dos pap√©is do usu√°rio
        var permissoes = await _roleManager.Roles
            .Where(r => papeis.Contains(r.Name!))
            .SelectMany(r => r.PapelPermissoes
                .Where(pp => pp.Ativo)
                .Select(pp => pp.Permissao.Nome))
            .Distinct()
            .ToListAsync();

        return permissoes;
    }

    /// <summary>
    /// Obt√©m a expira√ß√£o do token atual
    /// </summary>
    private DateTime? GetTokenExpiration()
    {
        // ‚úÖ TENTAR DIFERENTES CLAIMS DE EXPIRA√á√ÉO
        var exp = User.FindFirstValue("exp") ?? 
                  User.FindFirstValue(OpenIddictConstants.Claims.ExpiresAt);
        
        if (long.TryParse(exp, out var expUnix))
        {
            return DateTimeOffset.FromUnixTimeSeconds(expUnix).DateTime;
        }
        return null;
    }

    #endregion
}

#region DTOs de Autentica√ß√£o

/// <summary>
/// Dados para solicita√ß√£o de login
/// </summary>
public class SolicitacaoLogin
{
    /// <summary>
    /// Email do usu√°rio
    /// </summary>
    [Required(ErrorMessage = "Email √© obrigat√≥rio")]
    [EmailAddress(ErrorMessage = "Email deve ter formato v√°lido")]
    public string Email { get; set; } = string.Empty;

    /// <summary>
    /// Senha do usu√°rio
    /// </summary>
    [Required(ErrorMessage = "Senha √© obrigat√≥ria")]
    [MinLength(6, ErrorMessage = "Senha deve ter pelo menos 6 caracteres")]
    public string Senha { get; set; } = string.Empty;

    /// <summary>
    /// Lembrar login (manter sess√£o)
    /// </summary>
    public bool LembrarLogin { get; set; } = false;
}

/// <summary>
/// Dados para renova√ß√£o de token
/// </summary>
public class SolicitacaoRefresh
{
    /// <summary>
    /// Refresh token
    /// </summary>
    [Required(ErrorMessage = "Refresh token √© obrigat√≥rio")]
    public string RefreshToken { get; set; } = string.Empty;
}

/// <summary>
/// Resposta de login bem-sucedido
/// </summary>
public class RespostaLogin
{
    /// <summary>
    /// Indica se o login foi bem-sucedido
    /// </summary>
    public bool Sucesso { get; set; }

    /// <summary>
    /// Token de acesso
    /// </summary>
    public string Token { get; set; } = string.Empty;

    /// <summary>
    /// Tipo do token (Bearer)
    /// </summary>
    public string TipoToken { get; set; } = "Bearer";

    /// <summary>
    /// Data/hora de expira√ß√£o do token
    /// </summary>
    public DateTime ExpiracaoEm { get; set; }

    /// <summary>
    /// Token para renova√ß√£o
    /// </summary>
    public string RefreshToken { get; set; } = string.Empty;

    /// <summary>
    /// Informa√ß√µes do usu√°rio logado
    /// </summary>
    public InformacoesUsuario Usuario { get; set; } = null!;
}

/// <summary>
/// Resposta de renova√ß√£o de token
/// </summary>
public class RespostaToken
{
    /// <summary>
    /// Novo token de acesso
    /// </summary>
    public string Token { get; set; } = string.Empty;

    /// <summary>
    /// Tipo do token
    /// </summary>
    public string TipoToken { get; set; } = "Bearer";

    /// <summary>
    /// Data/hora de expira√ß√£o
    /// </summary>
    public DateTime ExpiracaoEm { get; set; }

    /// <summary>
    /// Novo refresh token
    /// </summary>
    public string RefreshToken { get; set; } = string.Empty;
}

/// <summary>
/// Informa√ß√µes do usu√°rio
/// </summary>
public class InformacoesUsuario
{
    /// <summary>
    /// ID do usu√°rio
    /// </summary>
    public int Id { get; set; }

    /// <summary>
    /// Email do usu√°rio
    /// </summary>
    public string Email { get; set; } = string.Empty;

    /// <summary>
    /// Nome do usu√°rio
    /// </summary>
    public string Nome { get; set; } = string.Empty;

    /// <summary>
    /// Sobrenome do usu√°rio
    /// </summary>
    public string Sobrenome { get; set; } = string.Empty;

    /// <summary>
    /// Nome completo do usu√°rio
    /// </summary>
    public string NomeCompleto { get; set; } = string.Empty;

    /// <summary>
    /// Data/hora do √∫ltimo login
    /// </summary>
    public DateTime? UltimoLogin { get; set; }

    /// <summary>
    /// Lista de pap√©is do usu√°rio
    /// </summary>
    public List<string> Papeis { get; set; } = new();

    /// <summary>
    /// Lista de permiss√µes do usu√°rio
    /// </summary>
    public List<string> Permissoes { get; set; } = new();
}

/// <summary>
/// Resposta de valida√ß√£o de token
/// </summary>
public class RespostaValidacaoToken
{
    /// <summary>
    /// Indica se o token √© v√°lido
    /// </summary>
    public bool Valido { get; set; }

    /// <summary>
    /// ID do usu√°rio
    /// </summary>
    public string? UsuarioId { get; set; }

    /// <summary>
    /// Email do usu√°rio
    /// </summary>
    public string? Email { get; set; }

    /// <summary>
    /// Pap√©is do usu√°rio
    /// </summary>
    public List<string> Papeis { get; set; } = new();

    /// <summary>
    /// Lista de permiss√µes do usu√°rio
    /// </summary>
    public List<string> Permissoes { get; set; } = new();

    /// <summary>
    /// Data/hora de expira√ß√£o do token
    /// </summary>
    public DateTime? ExpiracaoEm { get; set; }
}

/// <summary>
/// Resposta gen√©rica de sucesso
/// </summary>
public class RespostaSucesso
{
    /// <summary>
    /// Indica se a opera√ß√£o foi bem-sucedida
    /// </summary>
    public bool Sucesso { get; set; }

    /// <summary>
    /// Mensagem de sucesso
    /// </summary>
    public string Mensagem { get; set; } = string.Empty;
}

/// <summary>
/// Resposta gen√©rica de erro
/// </summary>
public class RespostaErro
{
    /// <summary>
    /// C√≥digo do erro
    /// </summary>
    public string Erro { get; set; } = string.Empty;

    /// <summary>
    /// Mensagem do erro
    /// </summary>
    public string Mensagem { get; set; } = string.Empty;

    /// <summary>
    /// Detalhes adicionais do erro
    /// </summary>
    public List<string>? Detalhes { get; set; }
}

/// <summary>
/// Informa√ß√µes do token gerado
/// </summary>
internal class TokenInfo
{
    public string Token { get; set; } = string.Empty;
    public DateTime ExpiracaoEm { get; set; }
    public string RefreshToken { get; set; } = string.Empty;
}

#endregion