using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Identity;
using Microsoft.AspNetCore.Authorization;
using OpenIddict.Abstractions;
using OpenIddict.Server.AspNetCore;
using Gestus.Modelos;
using System.Security.Claims;
using Microsoft.EntityFrameworkCore;
using System.ComponentModel.DataAnnotations;

namespace Gestus.Controllers;

/// <summary>
/// Controlador respons√°vel pela autentica√ß√£o de usu√°rios
/// </summary>
[ApiController]
[Route("api/[controller]")]
[Produces("application/json")]
public class AutenticacaoController : ControllerBase
{
    private readonly UserManager<Usuario> _userManager;
    private readonly SignInManager<Usuario> _signInManager;
    private readonly RoleManager<Papel> _roleManager;
    private readonly ILogger<AutenticacaoController> _logger;

    public AutenticacaoController(
        UserManager<Usuario> userManager,
        SignInManager<Usuario> signInManager,
        RoleManager<Papel> roleManager,
        ILogger<AutenticacaoController> logger)
    {
        _userManager = userManager;
        _signInManager = signInManager;
        _roleManager = roleManager;
        _logger = logger;
    }

    /// <summary>
    /// Realiza o login do usu√°rio
    /// </summary>
    /// <param name="request">Dados de login</param>
    /// <returns>Token de acesso e informa√ß√µes do usu√°rio</returns>
    [HttpPost("login")]
    [ProducesResponseType(typeof(RespostaLogin), StatusCodes.Status200OK)]
    [ProducesResponseType(typeof(RespostaErro), StatusCodes.Status400BadRequest)]
    [ProducesResponseType(typeof(RespostaErro), StatusCodes.Status401Unauthorized)]
    public async Task<IActionResult> Login([FromBody] SolicitacaoLogin request)
    {
        try
        {
            _logger.LogInformation("üîê Tentativa de login para: {Email}", request.Email);

            // 1. Validar dados de entrada
            if (!ModelState.IsValid)
            {
                return BadRequest(new RespostaErro
                {
                    Erro = "DadosInvalidos",
                    Mensagem = "Dados de login inv√°lidos",
                    Detalhes = ModelState.Values.SelectMany(v => v.Errors).Select(e => e.ErrorMessage).ToList()
                });
            }

            // 2. Buscar usu√°rio por email
            var usuario = await _userManager.FindByEmailAsync(request.Email);
            if (usuario == null)
            {
                _logger.LogWarning("‚ö†Ô∏è Tentativa de login com email inexistente: {Email}", request.Email);
                return Unauthorized(new RespostaErro
                {
                    Erro = "CredenciaisInvalidas",
                    Mensagem = "Email ou senha incorretos"
                });
            }

            // 3. Verificar se usu√°rio est√° ativo
            if (!usuario.Ativo)
            {
                _logger.LogWarning("‚ö†Ô∏è Tentativa de login com usu√°rio inativo: {Email}", request.Email);
                return Unauthorized(new RespostaErro
                {
                    Erro = "UsuarioInativo",
                    Mensagem = "Usu√°rio est√° inativo. Entre em contato com o administrador."
                });
            }

            // 4. Verificar senha
            var resultadoLogin = await _signInManager.CheckPasswordSignInAsync(usuario, request.Senha, true);
            
            if (resultadoLogin.IsLockedOut)
            {
                _logger.LogWarning("‚ö†Ô∏è Usu√°rio bloqueado: {Email}", request.Email);
                return Unauthorized(new RespostaErro
                {
                    Erro = "UsuarioBloqueado",
                    Mensagem = "Usu√°rio temporariamente bloqueado devido a muitas tentativas de login incorretas"
                });
            }

            if (!resultadoLogin.Succeeded)
            {
                _logger.LogWarning("‚ö†Ô∏è Senha incorreta para: {Email}", request.Email);
                return Unauthorized(new RespostaErro
                {
                    Erro = "CredenciaisInvalidas",
                    Mensagem = "Email ou senha incorretos"
                });
            }

            // 5. Atualizar √∫ltimo login
            usuario.UltimoLogin = DateTime.UtcNow;
            await _userManager.UpdateAsync(usuario);

            // 6. Obter pap√©is e permiss√µes do usu√°rio
            var papeis = await _userManager.GetRolesAsync(usuario);
            var permissoes = await ObterPermissoesUsuario(usuario.Id);

            // 7. Gerar token
            var token = await GerarTokenAcesso(usuario, papeis, permissoes);

            _logger.LogInformation("‚úÖ Login realizado com sucesso para: {Email}", request.Email);

            return Ok(new RespostaLogin
            {
                Sucesso = true,
                Token = token.Token,
                TipoToken = "Bearer",
                ExpiracaoEm = token.ExpiracaoEm,
                RefreshToken = token.RefreshToken,
                Usuario = new InformacoesUsuario
                {
                    Id = usuario.Id,
                    Email = usuario.Email!,
                    Nome = usuario.Nome,
                    Sobrenome = usuario.Sobrenome,
                    NomeCompleto = usuario.NomeCompleto ?? $"{usuario.Nome} {usuario.Sobrenome}",
                    UltimoLogin = usuario.UltimoLogin,
                    Papeis = papeis.ToList(),
                    Permissoes = permissoes
                }
            });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "‚ùå Erro durante o login para: {Email}", request.Email);
            return StatusCode(500, new RespostaErro
            {
                Erro = "ErroInterno",
                Mensagem = "Erro interno do servidor"
            });
        }
    }

    /// <summary>
    /// Renova o token de acesso usando o refresh token
    /// </summary>
    /// <param name="request">Refresh token</param>
    /// <returns>Novo token de acesso</returns>
    [HttpPost("refresh")]
    [ProducesResponseType(typeof(RespostaToken), StatusCodes.Status200OK)]
    [ProducesResponseType(typeof(RespostaErro), StatusCodes.Status400BadRequest)]
    [ProducesResponseType(typeof(RespostaErro), StatusCodes.Status401Unauthorized)]
    public async Task<IActionResult> Refresh([FromBody] SolicitacaoRefresh request)
    {
        try
        {
            _logger.LogInformation("üîÑ Tentativa de renova√ß√£o de token");

            if (!ModelState.IsValid || string.IsNullOrEmpty(request.RefreshToken))
            {
                return BadRequest(new RespostaErro
                {
                    Erro = "RefreshTokenInvalido",
                    Mensagem = "Refresh token √© obrigat√≥rio"
                });
            }

            // TODO: Implementar valida√ß√£o do refresh token com OpenIddict
            // Por enquanto, retornamos erro para implementar depois
            
            return Unauthorized(new RespostaErro
            {
                Erro = "RefreshTokenExpirado",
                Mensagem = "Refresh token inv√°lido ou expirado. Fa√ßa login novamente."
            });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "‚ùå Erro durante renova√ß√£o do token");
            return StatusCode(500, new RespostaErro
            {
                Erro = "ErroInterno",
                Mensagem = "Erro interno do servidor"
            });
        }
    }

    /// <summary>
    /// Realiza o logout do usu√°rio
    /// </summary>
    /// <returns>Confirma√ß√£o de logout</returns>
    [HttpPost("logout")]
    [Authorize]
    [ProducesResponseType(typeof(RespostaSucesso), StatusCodes.Status200OK)]
    public async Task<IActionResult> Logout()
    {
        try
        {
            var userId = User.FindFirstValue(ClaimTypes.NameIdentifier);
            _logger.LogInformation("üö™ Logout do usu√°rio: {UserId}", userId);

            await _signInManager.SignOutAsync();

            return Ok(new RespostaSucesso
            {
                Sucesso = true,
                Mensagem = "Logout realizado com sucesso"
            });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "‚ùå Erro durante logout");
            return StatusCode(500, new RespostaErro
            {
                Erro = "ErroInterno",
                Mensagem = "Erro interno do servidor"
            });
        }
    }

    /// <summary>
    /// Obt√©m informa√ß√µes do usu√°rio autenticado
    /// </summary>
    /// <returns>Informa√ß√µes do usu√°rio logado</returns>
    [HttpGet("perfil")]
    [Authorize]
    [ProducesResponseType(typeof(InformacoesUsuario), StatusCodes.Status200OK)]
    [ProducesResponseType(typeof(RespostaErro), StatusCodes.Status401Unauthorized)]
    public async Task<IActionResult> ObterPerfil()
    {
        try
        {
            var userId = User.FindFirstValue(ClaimTypes.NameIdentifier);
            
            if (string.IsNullOrEmpty(userId) || !int.TryParse(userId, out var userIdInt))
            {
                return Unauthorized();
            }

            var usuario = await _userManager.FindByIdAsync(userId);
            if (usuario == null || !usuario.Ativo)
            {
                return Unauthorized();
            }

            var papeis = await _userManager.GetRolesAsync(usuario);
            var permissoes = await ObterPermissoesUsuario(userIdInt);

            return Ok(new InformacoesUsuario
            {
                Id = usuario.Id,
                Email = usuario.Email!,
                Nome = usuario.Nome,
                Sobrenome = usuario.Sobrenome,
                NomeCompleto = usuario.NomeCompleto ?? $"{usuario.Nome} {usuario.Sobrenome}",
                UltimoLogin = usuario.UltimoLogin,
                Papeis = papeis.ToList(),
                Permissoes = permissoes
            });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "‚ùå Erro ao obter perfil do usu√°rio");
            return StatusCode(500, new RespostaErro
            {
                Erro = "ErroInterno",
                Mensagem = "Erro interno do servidor"
            });
        }
    }

    /// <summary>
    /// Verifica se o token √© v√°lido
    /// </summary>
    /// <returns>Status do token</returns>
    [HttpGet("validar-token")]
    [ProducesResponseType(typeof(RespostaValidacaoToken), StatusCodes.Status200OK)]
    [ProducesResponseType(typeof(RespostaErro), StatusCodes.Status401Unauthorized)]
    public async Task<IActionResult> ValidarToken()
    {
        try
        {
            // ‚úÖ VALIDA√á√ÉO TEMPOR√ÅRIA PARA MOCK TOKENS
            var authHeader = Request.Headers.Authorization.FirstOrDefault();
            
            if (string.IsNullOrEmpty(authHeader) || !authHeader.StartsWith("Bearer "))
            {
                return Unauthorized(new RespostaErro
                {
                    Erro = "TokenAusente",
                    Mensagem = "Token de autoriza√ß√£o n√£o fornecido"
                });
            }

            var token = authHeader.Substring("Bearer ".Length).Trim();
            
            // Validar se √© um mock token v√°lido (formato: mock_token_{userId}_{timestamp})
            if (!token.StartsWith("mock_token_"))
            {
                return Unauthorized(new RespostaErro
                {
                    Erro = "TokenInvalido",
                    Mensagem = "Formato de token inv√°lido"
                });
            }

            // ‚úÖ CORRIGIDO: Extrair userId do mock token corretamente
            var tokenParts = token.Split('_');
            
            // Debug log para ver as partes do token
            _logger.LogInformation("üîç Token parts: {Parts}", string.Join(" | ", tokenParts));
            
            // Formato esperado: ["mock", "token", "userId", "timestamp"]
            if (tokenParts.Length != 4)
            {
                return Unauthorized(new RespostaErro
                {
                    Erro = "TokenInvalido",
                    Mensagem = $"Token corrompido - partes: {tokenParts.Length}"
                });
            }

            // ‚úÖ CORRIGIDO: userId est√° na posi√ß√£o 2 (n√£o 3)
            if (!int.TryParse(tokenParts[2], out var userId))
            {
                return Unauthorized(new RespostaErro
                {
                    Erro = "TokenInvalido",
                    Mensagem = $"UserId inv√°lido no token: {tokenParts[2]}"
                });
            }

            // Buscar usu√°rio pelo ID extra√≠do do token
            var usuario = await _userManager.FindByIdAsync(userId.ToString());
            if (usuario == null || !usuario.Ativo)
            {
                return Unauthorized(new RespostaErro
                {
                    Erro = "UsuarioInvalido",
                    Mensagem = "Usu√°rio n√£o encontrado ou inativo"
                });
            }

            // Obter pap√©is e permiss√µes
            var papeis = await _userManager.GetRolesAsync(usuario);
            var permissoes = await ObterPermissoesUsuario(usuario.Id);

            _logger.LogInformation("‚úÖ Token validado para usu√°rio: {Email} (ID: {UserId})", usuario.Email, usuario.Id);

            return Ok(new RespostaValidacaoToken
            {
                Valido = true,
                UsuarioId = usuario.Id.ToString(),
                Email = usuario.Email,
                Papeis = papeis.ToList(),
                Permissoes = permissoes,
                ExpiracaoEm = DateTime.UtcNow.AddHours(1) // Mock expiration
            });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "‚ùå Erro ao validar token");
            return StatusCode(500, new RespostaErro
            {
                Erro = "ErroInterno",
                Mensagem = "Erro interno do servidor"
            });
        }
    }

    #region M√©todos Privados

    /// <summary>
    /// Gera token de acesso para o usu√°rio
    /// </summary>
    private async Task<TokenInfo> GerarTokenAcesso(Usuario usuario, IList<string> papeis, List<string> permissoes)
    {
        // TODO: Implementar gera√ß√£o de token JWT com OpenIddict
        // Por enquanto, retornar token mock para desenvolvimento
        
        var expiracaoEm = DateTime.UtcNow.AddHours(1);
        
        return new TokenInfo
        {
            Token = $"mock_token_{usuario.Id}_{DateTimeOffset.UtcNow.ToUnixTimeSeconds()}",
            ExpiracaoEm = expiracaoEm,
            RefreshToken = $"mock_refresh_{usuario.Id}_{DateTimeOffset.UtcNow.ToUnixTimeSeconds()}"
        };
    }

    /// <summary>
    /// Obt√©m todas as permiss√µes de um usu√°rio (atrav√©s dos pap√©is)
    /// </summary>
    private async Task<List<string>> ObterPermissoesUsuario(int usuarioId)
    {
        var usuario = await _userManager.Users
            .Where(u => u.Id == usuarioId)
            .FirstOrDefaultAsync();

        if (usuario == null) return new List<string>();

        var papeis = await _userManager.GetRolesAsync(usuario);
        
        // Buscar permiss√µes atrav√©s dos pap√©is do usu√°rio
        var permissoes = await _roleManager.Roles
            .Where(r => papeis.Contains(r.Name!))
            .SelectMany(r => r.PapelPermissoes
                .Where(pp => pp.Ativo)
                .Select(pp => pp.Permissao.Nome))
            .Distinct()
            .ToListAsync();

        return permissoes;
    }

    /// <summary>
    /// Obt√©m a expira√ß√£o do token atual
    /// </summary>
    private DateTime? GetTokenExpiration()
    {
        var exp = User.FindFirstValue("exp");
        if (long.TryParse(exp, out var expUnix))
        {
            return DateTimeOffset.FromUnixTimeSeconds(expUnix).DateTime;
        }
        return null;
    }

    #endregion
}

#region DTOs de Autentica√ß√£o

/// <summary>
/// Dados para solicita√ß√£o de login
/// </summary>
public class SolicitacaoLogin
{
    /// <summary>
    /// Email do usu√°rio
    /// </summary>
    [Required(ErrorMessage = "Email √© obrigat√≥rio")]
    [EmailAddress(ErrorMessage = "Email deve ter formato v√°lido")]
    public string Email { get; set; } = string.Empty;

    /// <summary>
    /// Senha do usu√°rio
    /// </summary>
    [Required(ErrorMessage = "Senha √© obrigat√≥ria")]
    [MinLength(6, ErrorMessage = "Senha deve ter pelo menos 6 caracteres")]
    public string Senha { get; set; } = string.Empty;

    /// <summary>
    /// Lembrar login (manter sess√£o)
    /// </summary>
    public bool LembrarLogin { get; set; } = false;
}

/// <summary>
/// Dados para renova√ß√£o de token
/// </summary>
public class SolicitacaoRefresh
{
    /// <summary>
    /// Refresh token
    /// </summary>
    [Required(ErrorMessage = "Refresh token √© obrigat√≥rio")]
    public string RefreshToken { get; set; } = string.Empty;
}

/// <summary>
/// Resposta de login bem-sucedido
/// </summary>
public class RespostaLogin
{
    /// <summary>
    /// Indica se o login foi bem-sucedido
    /// </summary>
    public bool Sucesso { get; set; }

    /// <summary>
    /// Token de acesso
    /// </summary>
    public string Token { get; set; } = string.Empty;

    /// <summary>
    /// Tipo do token (Bearer)
    /// </summary>
    public string TipoToken { get; set; } = "Bearer";

    /// <summary>
    /// Data/hora de expira√ß√£o do token
    /// </summary>
    public DateTime ExpiracaoEm { get; set; }

    /// <summary>
    /// Token para renova√ß√£o
    /// </summary>
    public string RefreshToken { get; set; } = string.Empty;

    /// <summary>
    /// Informa√ß√µes do usu√°rio logado
    /// </summary>
    public InformacoesUsuario Usuario { get; set; } = null!;
}

/// <summary>
/// Resposta de renova√ß√£o de token
/// </summary>
public class RespostaToken
{
    /// <summary>
    /// Novo token de acesso
    /// </summary>
    public string Token { get; set; } = string.Empty;

    /// <summary>
    /// Tipo do token
    /// </summary>
    public string TipoToken { get; set; } = "Bearer";

    /// <summary>
    /// Data/hora de expira√ß√£o
    /// </summary>
    public DateTime ExpiracaoEm { get; set; }

    /// <summary>
    /// Novo refresh token
    /// </summary>
    public string RefreshToken { get; set; } = string.Empty;
}

/// <summary>
/// Informa√ß√µes do usu√°rio
/// </summary>
public class InformacoesUsuario
{
    /// <summary>
    /// ID do usu√°rio
    /// </summary>
    public int Id { get; set; }

    /// <summary>
    /// Email do usu√°rio
    /// </summary>
    public string Email { get; set; } = string.Empty;

    /// <summary>
    /// Nome do usu√°rio
    /// </summary>
    public string Nome { get; set; } = string.Empty;

    /// <summary>
    /// Sobrenome do usu√°rio
    /// </summary>
    public string Sobrenome { get; set; } = string.Empty;

    /// <summary>
    /// Nome completo do usu√°rio
    /// </summary>
    public string NomeCompleto { get; set; } = string.Empty;

    /// <summary>
    /// Data/hora do √∫ltimo login
    /// </summary>
    public DateTime? UltimoLogin { get; set; }

    /// <summary>
    /// Lista de pap√©is do usu√°rio
    /// </summary>
    public List<string> Papeis { get; set; } = new();

    /// <summary>
    /// Lista de permiss√µes do usu√°rio
    /// </summary>
    public List<string> Permissoes { get; set; } = new();
}

/// <summary>
/// Resposta de valida√ß√£o de token
/// </summary>
public class RespostaValidacaoToken
{
    /// <summary>
    /// Indica se o token √© v√°lido
    /// </summary>
    public bool Valido { get; set; }

    /// <summary>
    /// ID do usu√°rio
    /// </summary>
    public string? UsuarioId { get; set; }

    /// <summary>
    /// Email do usu√°rio
    /// </summary>
    public string? Email { get; set; }

    /// <summary>
    /// Pap√©is do usu√°rio
    /// </summary>
    public List<string> Papeis { get; set; } = new();

    /// <summary>
    /// Lista de permiss√µes do usu√°rio
    /// </summary>
    public List<string> Permissoes { get; set; } = new();

    /// <summary>
    /// Data/hora de expira√ß√£o do token
    /// </summary>
    public DateTime? ExpiracaoEm { get; set; }
}

/// <summary>
/// Resposta gen√©rica de sucesso
/// </summary>
public class RespostaSucesso
{
    /// <summary>
    /// Indica se a opera√ß√£o foi bem-sucedida
    /// </summary>
    public bool Sucesso { get; set; }

    /// <summary>
    /// Mensagem de sucesso
    /// </summary>
    public string Mensagem { get; set; } = string.Empty;
}

/// <summary>
/// Resposta gen√©rica de erro
/// </summary>
public class RespostaErro
{
    /// <summary>
    /// C√≥digo do erro
    /// </summary>
    public string Erro { get; set; } = string.Empty;

    /// <summary>
    /// Mensagem do erro
    /// </summary>
    public string Mensagem { get; set; } = string.Empty;

    /// <summary>
    /// Detalhes adicionais do erro
    /// </summary>
    public List<string>? Detalhes { get; set; }
}

/// <summary>
/// Informa√ß√µes do token gerado
/// </summary>
internal class TokenInfo
{
    public string Token { get; set; } = string.Empty;
    public DateTime ExpiracaoEm { get; set; }
    public string RefreshToken { get; set; } = string.Empty;
}

#endregion